
const fs = require("fs");
const path = require("path");
const axios = require("axios");
require("dotenv").config();

//------------
// I - HELPERS
//------------

const isInternal = (item = {}) => item.type === "INTERNAL";
const pagesDirectory = path.join(__dirname, "../../../pages");
const isWrapper = (item = {}) => item.items && item.items.length > 0;
const navigationsLayers  = ["ancestors", "parent", "siblings", "children"];
const isIndexedWrapper = (item = {}) => isWrapper(item) && item.type === "INTERNAL";
const hasRelated = (item = {}) => item.related && Object.keys(item.related).length > 0;

const whiteList = [
  "api",
  "404.js",
  "_app.js",
  "index.js",
  "_error.js",
  "actualites",
  "_document.js"
];

const createTemplate = (filePath = "", item ) => {
  try {
    fs.writeFileSync(
      filePath,
      pageTemplate({ ...item, pageId: item.related.id })
    );
  } catch (error) {
    console.error(error);
  }
};

//------------
// II - EXPORTS
//------------

const fetchMainNavigationStruc = () =>
  new Promise((resolve, reject) => {
    axios
      .get(`${process.env.API_URL}/navigation/render/main-navigation/?type=tree`)
      .then(response => {
        resolve(response.data);
      })
      .catch(error => {
        reject(error);
      });
  });

const pageTemplate = item => {
  const { pageId, path }  = item;
  return `/*
 * !!! DO NOT EDIT THIS FILE !!!
 * ------------------------------
 * INFOS:
 *  - path: ./pages${path}
 *  - pageId: ${pageId}
 *  - last update: ${new Date().toLocaleString()}
 * ------------------------------
 */

import React from "react";

import PageServices from "@Services/Page";
import PageRenderer from "@Modules/PageRenderer";

export default function _nextJSPageTemplate(p){return <PageRenderer {...p} />;}

export const getStaticProps = async () => {
  let page = {};

  try {
    page = await PageServices.get("${pageId}");
  } catch (error) {
    console.error(error.message);
  }

  return {
    props: {
      ...page
    }
  };
};
`;
};

const cleanLayers = () => {
  fs.readdirSync(pagesDirectory, { withFileTypes: true })
    .forEach(item => {

      if (whiteList.includes(item.name)) return;

      const target = path.join(pagesDirectory, item.name);

      if (item.isFile()) {
        console.info(`üóë  Deleting file ‚Üí ${target}`);
        fs.unlinkSync(target);
        return;
      }
      if (item.isDirectory()) {
        console.info(`üóë  Deleting directory ‚Üí ${target}`);
        fs.rmSync(path.join(target), { recursive: true, force: true });
      }
    });
};

const buildNextJsLayers = (items, layer = navigationsLayers[0], parent= "",) =>
  items.map(item => {
    console.group(`- ${item.title}`);
    const explosedPath = item.path.split("/");

    // In the case our page as children, we need to create a directory for it
    if (isWrapper(item)) {
      const dirPath =
        `${parent ? parent + "/" : ""}${explosedPath[explosedPath.length - 1]}`;
      if (!fs.existsSync(pagesDirectory + "/" + dirPath)) {
        console.info(`üìÇ Creating new page directory ‚Üí ${dirPath}`);
        try {
          fs.mkdirSync(pagesDirectory + "/" + dirPath);
        } catch (error) {
          console.error(error);
        }
      }

      // If our page has content we need to create an index.js file
      if (isIndexedWrapper(item) && hasRelated(item)) {
        const indexPath = path.join(pagesDirectory, dirPath, "index.js");
        console.info(`üìù Creating index.js in ‚Üí ${dirPath}`);
        createTemplate(indexPath, item);
      }

    // Otherwise we create a page file with the slugified name
    } else if (isInternal(item) && hasRelated(item)) {
      if (item.path === "/") return;
      const filePath =
        path.join(`${parent ? parent + "/" : ""}${explosedPath[explosedPath.length - 1]}.js`);
      createTemplate(path.join(pagesDirectory, filePath), item);
    }

    // If page has no children and no content, let's inform the user
    if (!isWrapper(item) && !hasRelated(item)) {
      console.info("‚è≠  This page has no content nore children. Ignoring...");
    }

    const newParent = `${parent ? parent + "/" : ""}${explosedPath[explosedPath.length - 1]}`;
    if (item.items) buildNextJsLayers(item.items, navigationsLayers[navigationsLayers.indexOf(layer) + 1], newParent);
    console.groupEnd();
  });

module.exports = {
  fetchMainNavigationStruc,
  buildNextJsLayers,
  cleanLayers
};
